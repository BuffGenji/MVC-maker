<?php

declare(strict_types=1);

namespace App\Services\Factories;

use App\Components\Method;
use App\Components\Parameter;
use App\Components\Property;
use App\Services\Dialogue\ParameterDialogue;
use Exception;
use PhpParser\BuilderFactory;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\Assign;
use PhpParser\Node\Expr\Cast\String_;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Expr\PropertyFetch;
use PhpParser\Node\Expr\Variable;
use PhpParser\Node\Name;
use PhpParser\Node\Param;
use PhpParser\Node\Scalar\Int_;
use PhpParser\Node\Scalar\String_ as ScalarString_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Expression;
use PhpParser\Node\Stmt\Return_;

/**
 * This factory is slightly trickier given that parameters are embedded into the methodd and then for one we need the other
 * there are two situations here.
 * 
 * The first is that the methods are unique and the user will need to enter specific details
 * The second is boilerplate, such as getters and setters
 * 
 * In the event of the second one there will be special getter and setter functions
 * For the first there will be a dilogue created whenn the methods are made
 */

class MethodStatementFactory extends AbstractStatementFactory
{

    private BuilderFactory $factory;
    private ?array $methods;
    private array $properties_for_get_and_set;

    /**
     * The getters and setters option is there for added comfort when asking for elements in the EntityClass
     */
    public function __construct(
        ?array $methods = null,
        bool $want_getters_and_setters = false,
        array $properties_for_get_and_set = []
    ) {
        $this->builder = new BuilderFactory();
        $this->products = $this->createStatementsFor($methods);

        if ($want_getters_and_setters && empty($properties_for_get_and_set)) {
            throw new Exception('There are no properties');
        }

        $this->properties_for_get_and_set = $properties_for_get_and_set;
    }


    /**
     * Creates a ClassMethod node
     */
    public function createProduct($method): ClassMethod
    {
        /** To refactor  */
        echo "Do you want to add parameters to the {$method->getName()} method? (y/n)" . PHP_EOL;
        if (fgets(STDIN) == 'y') {
            $param_objects = (new ParameterDialogue)->getParameters();
            $param_statements = (new ParameterStatementFactory($param_objects))->getProducedStatements();
        } else {
            $param_statements = [];
        }

        // creation of node
        $node = $this->builder
            ->method($method->getName())
            ->makePublic()
            ->setReturnType($method->getType())
            ->addParams($param_statements)
            ->addStmt($this->returnStmtForType($method->getType()))
            ->getNode();
        return $node;
    }


    private function returnStmtForType(string $type)
    {

        switch ($type) {
            case 'int':
                $expr = new Int_(69);
                break;
            case 'string':
                $expr = new ScalarString_('Generated by yours truly');
                break;
            case 'bool':
                $expr = new Name('true');
                break;
            case 'array':
                $expr = new Array_([]);
                break;
            case 'void':
                $expr = null;
                break;
            default:
                $expr =  new Name('null');
                break;
        }

        return new Return_($expr);
    }

    /**
     * For other cases such as the Entity class ( needing basic getters and setters )
     * the functions below are provided
     */

    private function createGetter(Property $property): ClassMethod
    {
        $node = $this->builder->method('get' . ucfirst($property->getName()))
            ->makePublic()
            ->setReturnType($property->getType())
            ->addStmt(new Return_(new PropertyFetch(new Variable('this'), $property->getName())))
            ->getNode();
        return $node;
    }

    private function createSetter(Property $property): ClassMethod
    {
        // to refactor, very very ugly
        $factory = (new ParameterStatementFactory());
        $parameter = new Parameter([
            'name' => $property->getName(),
            'type' => $property->getType()
        ]);
        $parameter = $factory->createProduct($parameter);

        $node = $this->builder->method('set' . ucfirst($property->getName()))
            ->makePublic()
            ->addParam($parameter)
            ->addStmt(new Assign(
                new PropertyFetch(
                    new Variable('this'),
                    $property->getName()
                ),
                new Variable($property->getName())
            ))
            ->setReturnType('void')
            ->getNode();
        return $node;
    }

    /**
     * The properties are in fact Property objects,
     * this returns an array of statemenst ready to place in AST
     */
    public function createGettersAndSetters(): array
    {
        $boilerplate_get_and_set = [];
        foreach ($this->properties_for_get_and_set as $method) {
            $boilerplate_get_and_set[] = $this->createGetter($method);
            $boilerplate_get_and_set[] = $this->createSetter($method);
        }
        return $boilerplate_get_and_set;
    }
}
